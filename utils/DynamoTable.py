import os

import numpy as np

import utils.eulerAngles as ea
from .table_map_read import table_map_read
from .mrc_header_xyz import mrc_header_xyz


class DynamoTable:
    """A dynamo formatted table file"""

    def __init__(self, table_file=0, data=[]):
        self.file = table_file
        self.convention_dict = {1: 'tag tag of particle file in data folder',
                                2: 'aligned value 1: marks the particle for alignment',
                                3: 'averaged value 1: the particle was included in the average',
                                4: 'dx x shift from center (in pixels)',
                                5: 'dy y shift from center (in pixels)',
                                6: 'dz z shift from center (in pixels)',
                                7: 'tdrot euler angle (rotation around z, in degrees)',
                                8: 'tilt euler angle (rotation around new x, in degrees)',
                                9: 'narot euler angle (rotation around new z, in degrees)',
                                10: 'cc Cross correlation coefficient',
                                11: 'cc2 Cross correlation coefficient after thresholding II',
                                12: 'cpu processor that aligned the particle',
                                13: 'ftype 0: full range; 1: tilt around y ( ... dhelp dtutorial for more options)',
                                14: 'ymintilt minimum angle in the tilt series around tilt axis (i.e. -60)',
                                15: 'ymaxtilt maximum angle in the tilt series around tilt axis (i.e. 60)',
                                16: 'xmintilt minimum angle in the tilt series around second tilt axis (i.e. -60)',
                                17: 'xmaxtilt maximum angle in the tilt series around second x (i.e. 60)',
                                18: 'fs1 free parameter for fourier sampling #1()',
                                19: 'fs2 free parameter for fourier sampling #2()',
                                20: 'tomo tomogram number',
                                21: 'reg for arbitrary assignations of regions inside tomograms',
                                22: 'class class number',
                                23: 'annotation use this field for assigning arbitrary labels',
                                24: 'x x coordinate in original volume',
                                25: 'y y coordinate in original volume',
                                26: 'z z coordinate in original volume',
                                27: 'dshift norm of shift vector',
                                28: 'daxis difference in axis orientation',
                                29: 'dnarot difference in narot',
                                30: 'dcc difference in CC',
                                31: 'otag original tag (subboxing)',
                                32: 'npar number of added particles (compactions) / subunit label (subboxing)',
                                34: 'ref reference. Used in multireference projects',
                                35: 'sref subreference (i.e. generated by Dynamo PCA)',
                                36: 'apix angstrom per pixel',
                                37: 'def defocus (in micron)',
                                41: 'eig1 "eigencoefficient" #1',
                                42: 'eig2 "eigencoefficient" #2'}

        # Read Data
        if type(table_file) == str and os.path.isfile(table_file):
            self.data = np.loadtxt(table_file)
        elif table_file == 0:
            self.table_file = 0
        else:
            print("Error reading table file '{}', returning empty class instance".format(table_file))

        if 'numpy.ndarray' in str(type(data)):
            self.data = data

    # Methods 
    def convention(self, column=0):
        if column == 0:
            print(self.convention_dict)
        else:
            print(self.convention_dict[column])

    def xyz(self):
        "Function to calculate xyz coordinates from dynamo formatted table"
        xyz = self.data[:, 3:6] + self.data[:, 23:26]
        return xyz

    def eulers(self):
        "Function to read eulers (ZXZ - template onto particle) from dynamo_table"
        eulers = ea.eulerAngles(self.data[:, 6:9], 'ZXZ', 'template')
        self.eulers = eulers
        return eulers

    def tags(self):
        "Function to read tags from dynamo table"
        tags = self.data[:, 0]
        self.tags = tags
        return tags

    def cc(self):
        "Function to read cc from dynamo table"
        cc = self.data[:, 11]
        return cc

    def particles(self):
        "Prints number of particles in dynamo table"
        nParticles = self.data.shape[0]
        print("This table contains {} particles".format(nParticles))
        return nParticles

    def tomos(self):
        "Function to read tomogram id (column 20) from dynamo table"
        tomos = self.data[:, 19]
        unique_ids, counts = np.unique(tomos, return_counts=True)
        counter = 0
        for i in np.nditer(unique_ids):
            print("Tomogram with ID {:.0f} contains {} particles".format(i, counts[counter]))
            counter += 1
        self.unique_ids = unique_ids
        return tomos, unique_ids, counts

    def addTableMap(self, table_map_file):
        "Function to add info linking tomogram idx to tomogram file, tomogram table map file. Also checks tomogram size"
        if type(table_map_file) == str and os.path.isfile(table_map_file):
            self.table_map_file = table_map_file
            table_map = table_map_read(table_map_file)
            self.table_map = table_map

            # Check tomo sizes
            list_tomos = self.table_map.values()
            list_xyz = [mrc_header_xyz(tomo) for tomo in list_tomos]
            self.tomo_sizes = dict(zip(list_tomos, list_xyz))

    def dataFromTomogram(self, tomogram_id):
        "Function to retrieve data for only one tomogram id"
        data = self.data[self.data[:, 19] == tomogram_id, :]
        return data

    def unique(self):
        "Function to take dynamoTable object and construct list of dynamoTable objects, each containing only particles from one tomogram"
        # Use tomos method to find unique ids for each tomo
        tomos, unique_ids, counts = self.tomos()

        # iterate over unique ids and create new tables for each unique id
        list_of_tables = []

        for idx in unique_ids:
            table = DynamoTable(data=self.dataFromTomogram(idx))
            list_of_tables.append(table)

        return list_of_tables

    def currentBinning(self, current_binning):
        "Function to add into the dynamoTable object the binning factor for the xyz positions and shifts in the table"
        self.current_binning = current_binning

    def split(self):
        "Function to divide data from table into two groups, simple split along the direction (XYZ) of greatest variation"
        # store xyz
        xyz = self.xyz()

        # check range in x y and z
        ptp = np.ptp(xyz, 0)

        # find axis with greatest variation
        axis_idx = np.argmax(ptp)

        # find min, max and midpoint along that axis
        min_val = np.amin(xyz[:, axis_idx])
        max_val = np.amax(xyz[:, axis_idx])
        midpoint = (min_val + max_val) / 2.0

        # check which subgroup particles will go in #### MISSSING COMPARISON TO DATA?!?
        subgroup1_idx = np.greater_equal(xyz[:, axis_idx], midpoint)
        subgroup2_idx = np.less(xyz[:, axis_idx], midpoint)

        # access data for each subgroup
        data_subgroup1 = self.data[subgroup1_idx, :]
        data_subgroup2 = self.data[subgroup2_idx, :]

        # create new tables
        table_subgroup1 = DynamoTable(data=data_subgroup1)
        table_subgroup2 = DynamoTable(data=data_subgroup2)

        # return list of tables
        return [table_subgroup1, table_subgroup2]
